// src/extension/withJSONSchemaFeatures.ts
var JSON_SCHEMA_FEATURES_KEY = "__json_schema_features";
function withJSONSchemaFeatures(schema, features) {
  return Object.assign(schema, { [JSON_SCHEMA_FEATURES_KEY]: features });
}
function getJSONSchemaFeatures(schema) {
  return schema[JSON_SCHEMA_FEATURES_KEY];
}

// src/extension/assignExtraJSONSchemaFeatures.ts
function assignExtraJSONSchemaFeatures(schema, converted) {
  const jsonSchemaFeatures = getJSONSchemaFeatures(schema);
  if (jsonSchemaFeatures) {
    Object.assign(converted, jsonSchemaFeatures);
  }
}

// src/utils/assert.ts
function assert(value, predicate, message) {
  if (!predicate(value))
    throw new Error(message.replace("%", String(value)));
  return value;
}

// src/utils/json-schema.ts
var $schema = "http://json-schema.org/draft-07/schema#";
function isJSONLiteral(value) {
  return typeof value === "number" && !Number.isNaN(value) || typeof value === "string" || typeof value === "boolean" || value === null;
}
var assertJSONLiteral = (v) => assert(v, isJSONLiteral, "Unsupported literal value type: %");

// src/toJSONSchema/schemas.ts
import {
  getDefault
} from "valibot";

// src/utils/isEqual.ts
function isEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (typeof obj1 === "object" && typeof obj2 === "object") {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
      return false;
    return keys1.every((key1) => isEqual(obj1[key1], obj2[key1]));
  }
  return false;
}

// src/utils/valibot.ts
var isSchemaType = (type) => {
  return (schema) => !!schema && schema.type === type;
};
var isNullishSchema = isSchemaType("nullish");
var isOptionalSchema = isSchemaType("optional");
var isStringSchema = isSchemaType("string");
var isNeverSchema = isSchemaType("never");

// src/toJSONSchema/toDefinitionURI.ts
var toDefinitionURI = (name) => `#/definitions/${name}`;

// src/toJSONSchema/schemas.ts
var SCHEMA_CONVERTERS = {
  any: () => ({}),
  // Core types
  null: () => ({ const: null }),
  literal: ({ literal }) => ({ const: assertJSONLiteral(literal) }),
  number: () => ({ type: "number" }),
  string: () => ({ type: "string" }),
  boolean: () => ({ type: "boolean" }),
  // Compositions
  optional: (schema, convert) => {
    const output = convert(schema.wrapped);
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  nullish: (schema, convert) => {
    const output = { anyOf: [{ const: null }, convert(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  nullable: (schema, convert) => {
    const output = { anyOf: [{ const: null }, convert(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0)
      output.default = defaultValue;
    return output;
  },
  picklist: ({ options }) => ({ enum: options.map(assertJSONLiteral) }),
  union: ({ options }, convert) => ({ anyOf: options.map(convert) }),
  intersect: ({ options }, convert) => ({ allOf: options.map(convert) }),
  // Complex types
  array: ({ item }, convert) => ({ type: "array", items: convert(item) }),
  tuple({ items: originalItems, rest, pipe }, convert) {
    const minItems = originalItems.length;
    let maxItems;
    let items = originalItems.map(convert);
    let additionalItems;
    if (isNeverSchema(rest)) {
      maxItems = minItems;
    } else if (rest) {
      const restItems = convert(rest);
      if (items.length === 1 && isEqual(items[0], restItems)) {
        items = items[0];
      } else {
        additionalItems = restItems;
      }
    }
    return { type: "array", items, additionalItems, minItems, maxItems };
  },
  object({ entries, rest }, convert, context) {
    const properties = {};
    const required = [];
    for (const [propKey, propValue] of Object.entries(entries)) {
      const propSchema = propValue;
      if (!isOptionalSchema(propSchema) && !isNullishSchema(propSchema)) {
        required.push(propKey);
      }
      properties[propKey] = convert(propSchema);
      assignExtraJSONSchemaFeatures(propValue, properties[propKey]);
    }
    let additionalProperties;
    if (rest) {
      additionalProperties = isNeverSchema(rest) ? false : convert(rest);
    } else if (context.strictObjectTypes) {
      additionalProperties = false;
    }
    const output = { type: "object", properties };
    if (additionalProperties !== void 0)
      output.additionalProperties = additionalProperties;
    if (required.length)
      output.required = required;
    return output;
  },
  record({ key, value }, convert) {
    assert(key, isStringSchema, "Unsupported record key type: %");
    return { type: "object", additionalProperties: convert(value) };
  },
  recursive(schema, _, context) {
    const nested = schema.getter();
    const defName = context.defNameMap.get(nested);
    if (!defName) {
      throw new Error("Type inside recursive schema must be provided in the definitions");
    }
    return { $ref: toDefinitionURI(defName) };
  },
  date(_, __, context) {
    if (!context.dateStrategy) {
      throw new Error('The "dateStrategy" option must be set to handle date validators');
    }
    switch (context.dateStrategy) {
      case "integer":
        return { type: "integer", format: "unix-time" };
      case "string":
        return { type: "string", format: "date-time" };
    }
  }
};

// src/toJSONSchema/validations.ts
var VALIDATION_BY_SCHEMA = {
  array: {
    length: ({ requirement }) => ({ minItems: requirement, maxItems: requirement }),
    min_length: ({ requirement }) => ({ minItems: requirement }),
    max_length: ({ requirement }) => ({ maxItems: requirement })
  },
  string: {
    value: ({ requirement }) => ({ const: requirement }),
    length: ({ requirement }) => ({ minLength: requirement, maxLength: requirement }),
    min_length: ({ requirement }) => ({ minLength: requirement }),
    max_length: ({ requirement }) => ({ maxLength: requirement }),
    // TODO: validate RegExp features are compatible with json schema ?
    regex: ({ requirement }) => ({ pattern: requirement.source }),
    email: () => ({ format: "email" }),
    iso_date: () => ({ format: "date" }),
    iso_timestamp: () => ({ format: "date-time" }),
    ipv4: () => ({ format: "ipv4" }),
    ipv6: () => ({ format: "ipv6" }),
    uuid: () => ({ format: "uuid" })
  },
  number: {
    value: ({ requirement }) => ({ const: requirement }),
    min_value: ({ requirement }) => ({ minimum: requirement }),
    max_value: ({ requirement }) => ({ maximum: requirement }),
    multiple_of: ({ requirement }) => ({ multipleOf: requirement }),
    integer: () => ({ type: "integer" })
  },
  boolean: {
    value: ({ requirement }) => ({ const: requirement })
  }
};
function convertPipe(schemaType, ignoreUnknownValidation, pipe = []) {
  return pipe.reduce((def, validation) => {
    var _a;
    const validationType = validation.type;
    const validationConverter = (_a = VALIDATION_BY_SCHEMA[schemaType]) == null ? void 0 : _a[validationType];
    if (!validationConverter && ignoreUnknownValidation)
      return {};
    assert(validationConverter, Boolean, `Unsupported valibot validation \`${validationType}\` for schema \`${schemaType}\``);
    return Object.assign(def, validationConverter(validation));
  }, {});
}

// src/toJSONSchema/index.ts
function getDefNameMap(definitions = {}) {
  const map = /* @__PURE__ */ new Map();
  for (const [name, definition] of Object.entries(definitions)) {
    map.set(definition, name);
  }
  return map;
}
function createConverter(context) {
  const definitions = {};
  function converter(schema) {
    const defName = context.defNameMap.get(schema);
    const defURI = defName && toDefinitionURI(defName);
    if (defURI && defURI in definitions) {
      return { $ref: defURI };
    }
    const schemaConverter = SCHEMA_CONVERTERS[schema.type];
    assert(schemaConverter, Boolean, `Unsupported valibot schema: ${(schema == null ? void 0 : schema.type) || schema}`);
    const converted = schemaConverter(schema, converter, context);
    Object.assign(converted, convertPipe(schema.type, context.ignoreUnknownValidation, schema.pipe));
    assignExtraJSONSchemaFeatures(schema, converted);
    if (defURI) {
      definitions[defName] = converted;
      return { $ref: defURI };
    }
    return converted;
  }
  return { definitions, converter };
}
function toJSONSchema(options) {
  const { schema, definitions: inputDefinitions, ...more } = options;
  const defNameMap = getDefNameMap(inputDefinitions);
  const { definitions, converter } = createConverter({ defNameMap, ...more });
  if (!schema && !inputDefinitions) {
    throw new Error("No main schema or definitions provided.");
  }
  if (inputDefinitions) {
    Object.values(inputDefinitions).forEach(converter);
  }
  const mainConverted = schema && converter(schema);
  const mainDefName = schema && defNameMap.get(schema);
  const out = { $schema };
  if (mainDefName) {
    out.$ref = toDefinitionURI(mainDefName);
  } else {
    Object.assign(out, mainConverted);
  }
  if (Object.keys(definitions).length) {
    out.definitions = definitions;
  }
  return out;
}
export {
  toJSONSchema,
  withJSONSchemaFeatures
};
