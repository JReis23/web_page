import "./chunk-OKRZSAGO.js";
import {
  parse,
  stringify
} from "./chunk-ILSCI4CI.js";
import {
  derived,
  readonly,
  writable
} from "./chunk-4ZYAZVX4.js";
import {
  get_store_value,
  onDestroy,
  tick
} from "./chunk-SIWR6ZD5.js";
import "./chunk-OJ4D57XS.js";
import {
  __publicField
} from "./chunk-F3FYYIAV.js";

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/superForm.js
import { navigating, page } from "$app/stores";

// node_modules/.pnpm/just-clone@6.2.0/node_modules/just-clone/index.mjs
var collectionClone = clone;
function clone(obj) {
  let result = obj;
  var type = {}.toString.call(obj).slice(8, -1);
  if (type == "Set") {
    return new Set([...obj].map((value) => clone(value)));
  }
  if (type == "Map") {
    return new Map([...obj].map((kv) => [clone(kv[0]), clone(kv[1])]));
  }
  if (type == "Date") {
    return new Date(obj.getTime());
  }
  if (type == "RegExp") {
    return RegExp(obj.source, getRegExpFlags(obj));
  }
  if (type == "Array" || type == "Object") {
    result = Array.isArray(obj) ? [] : {};
    for (var key in obj) {
      result[key] = clone(obj[key]);
    }
  }
  return result;
}
function getRegExpFlags(regExp) {
  if (typeof regExp.source.flags == "string") {
    return regExp.source.flags;
  } else {
    var flags = [];
    regExp.global && flags.push("g");
    regExp.ignoreCase && flags.push("i");
    regExp.multiline && flags.push("m");
    regExp.sticky && flags.push("y");
    regExp.unicode && flags.push("u");
    return flags.join("");
  }
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/utils.js
function clone2(data) {
  return data && typeof data === "object" ? collectionClone(data) : data;
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/superForm.js
import { browser as browser2 } from "$app/environment";

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/traversal.js
function setPath(parent, key, value) {
  parent[key] = value;
  return "skip";
}
function isInvalidPath(originalPath, pathData) {
  return pathData.value !== void 0 && typeof pathData.value !== "object" && pathData.path.length < originalPath.length;
}
function pathExists(obj, path, options = {}) {
  if (!options.modifier) {
    options.modifier = (pathData) => isInvalidPath(path, pathData) ? void 0 : pathData.value;
  }
  const exists = traversePath(obj, path, options.modifier);
  if (!exists)
    return void 0;
  if (options.value === void 0)
    return exists;
  return options.value(exists.value) ? exists : void 0;
}
function traversePath(obj, realPath, modifier) {
  if (!realPath.length)
    return void 0;
  const path = [realPath[0]];
  let parent = obj;
  while (path.length < realPath.length) {
    const key2 = path[path.length - 1];
    const value = modifier ? modifier({
      parent,
      key: String(key2),
      value: parent[key2],
      path: path.map((p) => String(p)),
      isLeaf: false,
      set: (v) => setPath(parent, key2, v)
    }) : parent[key2];
    if (value === void 0)
      return void 0;
    else
      parent = value;
    path.push(realPath[path.length]);
  }
  if (!parent)
    return void 0;
  const key = realPath[realPath.length - 1];
  return {
    parent,
    key: String(key),
    value: parent[key],
    path: realPath.map((p) => String(p)),
    isLeaf: true,
    set: (v) => setPath(parent, key, v)
  };
}
function traversePaths(parent, modifier, path = []) {
  for (const key in parent) {
    const value = parent[key];
    const isLeaf = value === null || typeof value !== "object";
    const pathData = {
      parent,
      key,
      value,
      path: path.concat([key]),
      // path.map(String).concat([key])
      isLeaf,
      set: (v) => setPath(parent, key, v)
    };
    const status = modifier(pathData);
    if (status === "abort")
      return status;
    else if (status === "skip")
      continue;
    else if (!isLeaf) {
      const status2 = traversePaths(value, modifier, pathData.path);
      if (status2 === "abort")
        return status2;
    }
  }
}
function eqSet(xs, ys) {
  return xs === ys || xs.size === ys.size && [...xs].every((x) => ys.has(x));
}
function comparePaths(newObj, oldObj) {
  const diffPaths = /* @__PURE__ */ new Map();
  function checkPath(data, compareTo) {
    const exists = compareTo ? traversePath(compareTo, data.path) : void 0;
    function addDiff() {
      diffPaths.set(data.path.join(" "), data.path);
      return "skip";
    }
    if (data.isLeaf) {
      if (!exists) {
        addDiff();
      } else if (data.value !== exists.value) {
        addDiff();
      }
    } else if (exists) {
      if ((data.value instanceof Date || exists.value instanceof Date) && (!!data.value != !!exists.value || data.value.getTime() != exists.value.getTime())) {
        return addDiff();
      } else if ((data.value instanceof Set || exists.value instanceof Set) && (!!data.value != !!exists.value || !eqSet(data.value, exists.value))) {
        return addDiff();
      } else if ((data.value instanceof File || exists.value instanceof File) && (!!data.value != !!exists.value || data.value !== exists.value)) {
        return addDiff();
      }
    }
  }
  traversePaths(newObj, (data) => checkPath(data, oldObj));
  traversePaths(oldObj, (data) => checkPath(data, newObj));
  return Array.from(diffPaths.values());
}
function setPaths(obj, paths, value) {
  const isFunction = typeof value === "function";
  for (const path of paths) {
    const leaf = traversePath(obj, path, ({ parent, key, value: value2 }) => {
      if (value2 === void 0 || typeof value2 !== "object") {
        parent[key] = {};
      }
      return parent[key];
    });
    if (leaf)
      leaf.parent[leaf.key] = isFunction ? value(path, leaf) : value;
  }
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/stringPath.js
function splitPath(path) {
  return path.toString().split(/[[\].]+/).filter((p) => p);
}
function mergePath(path) {
  return path.reduce((acc, next) => {
    const key = String(next);
    if (typeof next === "number" || /^\d+$/.test(key))
      acc += `[${key}]`;
    else if (!acc)
      acc += key;
    else
      acc += `.${key}`;
    return acc;
  }, "");
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/superForm.js
import { beforeNavigate, goto, invalidateAll } from "$app/navigation";

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/jsonSchema/schemaInfo.js
var conversionFormatTypes = ["unix-time", "bigint", "any", "symbol", "set"];
function schemaInfo(schema, isOptional, path) {
  var _a;
  if (typeof schema === "boolean") {
    throw new SchemaError("Schema cannot be defined as boolean", path);
  }
  if (!path)
    throw new SchemaError("Why?", path);
  const types = schemaTypes(schema, path);
  const array = schema.items && types.includes("array") ? (Array.isArray(schema.items) ? schema.items : [schema.items]).filter((s) => typeof s !== "boolean") : void 0;
  const properties = schema.properties && types.includes("object") ? Object.fromEntries(Object.entries(schema.properties).filter(([, value]) => typeof value !== "boolean")) : void 0;
  const union = (_a = unionInfo(schema)) == null ? void 0 : _a.filter((u) => u.type !== "null" && u.const !== null);
  return {
    types: types.filter((s) => s !== "null"),
    isOptional,
    isNullable: types.includes("null"),
    schema,
    union: (union == null ? void 0 : union.length) ? union : void 0,
    array,
    properties,
    required: schema.required
  };
}
function schemaTypes(schema, path) {
  if (typeof schema === "boolean") {
    throw new SchemaError("Schema cannot be defined as boolean", path);
  }
  let types = schema.const === null ? ["null"] : [];
  if (schema.type) {
    types = Array.isArray(schema.type) ? schema.type : [schema.type];
  }
  if (schema.anyOf) {
    types = schema.anyOf.flatMap((s) => schemaTypes(s, path));
  }
  if (types.includes("array") && schema.uniqueItems) {
    const i = types.findIndex((t) => t != "array");
    types[i] = "set";
  } else if (schema.format && conversionFormatTypes.includes(schema.format)) {
    types.unshift(schema.format);
    if (schema.format == "unix-time") {
      const i = types.findIndex((t) => t == "integer");
      types.splice(i, 1);
    }
  }
  return Array.from(new Set(types));
}
function unionInfo(schema) {
  if (!schema.anyOf || !schema.anyOf.length)
    return void 0;
  return schema.anyOf.filter((s) => typeof s !== "boolean");
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/jsonSchema/schemaDefaults.js
function defaultValues(schema, isOptional = false, path = []) {
  return _defaultValues(schema, isOptional, path);
}
function _defaultValues(schema, isOptional, path) {
  var _a;
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  if (!info)
    return void 0;
  let objectDefaults = void 0;
  if ("default" in schema) {
    if (info.types.includes("object") && schema.default && typeof schema.default == "object" && !Array.isArray(schema.default)) {
      objectDefaults = schema.default;
    } else {
      if (info.types.length > 1) {
        if (info.types.includes("unix-time") && (info.types.includes("integer") || info.types.includes("number")))
          throw new SchemaError("Cannot resolve a default value with a union that includes a date and a number/integer.", path);
      }
      const [type] = info.types;
      return formatDefaultValue(type, schema.default);
    }
  }
  let _multiType;
  const isMultiTypeUnion = () => {
    if (!info.union || info.union.length < 2)
      return false;
    if (info.union.some((i) => i.enum))
      return true;
    if (!_multiType) {
      _multiType = new Set(info.types.map((i) => {
        return ["integer", "unix-time"].includes(i) ? "number" : i;
      }));
    }
    return _multiType.size > 1;
  };
  if (!objectDefaults && info.union) {
    const singleDefault = info.union.filter((s) => typeof s !== "boolean" && s.default !== void 0);
    if (singleDefault.length == 1) {
      return _defaultValues(singleDefault[0], isOptional, path);
    } else if (singleDefault.length > 1) {
      throw new SchemaError("Only one default value can exist in a union, or set a default value for the whole union.", path);
    } else {
      if (info.isNullable)
        return null;
      if (info.isOptional)
        return void 0;
      if (isMultiTypeUnion()) {
        throw new SchemaError("Multi-type unions must have a default value, or exactly one of the union types must have.", path);
      }
    }
  }
  if (!objectDefaults) {
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  if (info.properties) {
    const output = {};
    for (const [key, value] of Object.entries(info.properties)) {
      if (typeof value == "boolean") {
        throw new SchemaError("Property cannot be defined as boolean.", [...path, key]);
      }
      const def = objectDefaults && objectDefaults[key] !== void 0 ? objectDefaults[key] : _defaultValues(value, !((_a = schema.required) == null ? void 0 : _a.includes(key)), [...path, key]);
      output[key] = def;
    }
    return output;
  } else if (objectDefaults) {
    return objectDefaults;
  }
  if (schema.enum) {
    return schema.enum[0];
  }
  if (isMultiTypeUnion()) {
    throw new SchemaError("Default values cannot have more than one type.", path);
  } else if (info.types.length == 0) {
    return void 0;
  }
  const [formatType] = info.types;
  return defaultValue(formatType, schema.enum);
}
function formatDefaultValue(type, value) {
  switch (type) {
    case "set":
      return Array.isArray(value) ? new Set(value) : value;
    case "Date":
    case "date":
    case "unix-time":
      if (typeof value === "string" || typeof value === "number")
        return new Date(value);
      break;
    case "bigint":
      if (typeof value === "string" || typeof value === "number")
        return BigInt(value);
      break;
    case "symbol":
      if (typeof value === "string" || typeof value === "number")
        return Symbol(value);
      break;
  }
  return value;
}
function defaultValue(type, enumType) {
  switch (type) {
    case "string":
      return enumType && enumType.length > 0 ? enumType[0] : "";
    case "number":
    case "integer":
      return enumType && enumType.length > 0 ? enumType[0] : 0;
    case "boolean":
      return false;
    case "array":
      return [];
    case "object":
      return {};
    case "null":
      return null;
    case "Date":
    case "date":
    case "unix-time":
      return void 0;
    case "bigint":
      return BigInt(0);
    case "set":
      return /* @__PURE__ */ new Set();
    case "symbol":
      return Symbol();
    case "undefined":
    case "any":
      return void 0;
    default:
      throw new SchemaError("Schema type or format not supported, requires explicit default value: " + type);
  }
}
function defaultTypes(schema, path = []) {
  return _defaultTypes(schema, false, path);
}
function _defaultTypes(schema, isOptional, path) {
  var _a;
  if (!schema) {
    throw new SchemaError("Schema was undefined", path);
  }
  const info = schemaInfo(schema, isOptional, path);
  const output = {
    __types: info.types
  };
  if (info.schema.items && typeof info.schema.items == "object" && !Array.isArray(info.schema.items)) {
    output.__items = _defaultTypes(info.schema.items, info.isOptional, path);
  }
  if (info.properties) {
    for (const [key, value] of Object.entries(info.properties)) {
      if (typeof value == "boolean") {
        throw new SchemaError("Property cannot be defined as boolean.", [...path, key]);
      }
      output[key] = _defaultTypes(info.properties[key], !((_a = info.required) == null ? void 0 : _a.includes(key)), [
        ...path,
        key
      ]);
    }
  }
  if (info.isNullable && !output.__types.includes("null")) {
    output.__types.push("null");
  }
  if (info.isOptional && !output.__types.includes("undefined")) {
    output.__types.push("undefined");
  }
  return output;
}

// node_modules/.pnpm/ts-deepmerge@7.0.0/node_modules/ts-deepmerge/esm/index.js
var isObject = (obj) => {
  if (typeof obj === "object" && obj !== null) {
    if (typeof Object.getPrototypeOf === "function") {
      const prototype = Object.getPrototypeOf(obj);
      return prototype === Object.prototype || prototype === null;
    }
    return Object.prototype.toString.call(obj) === "[object Object]";
  }
  return false;
};
var merge = (...objects) => objects.reduce((result, current) => {
  if (Array.isArray(current)) {
    throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
  }
  Object.keys(current).forEach((key) => {
    if (["__proto__", "constructor", "prototype"].includes(key)) {
      return;
    }
    if (Array.isArray(result[key]) && Array.isArray(current[key])) {
      result[key] = merge.options.mergeArrays ? merge.options.uniqueArrayItems ? Array.from(new Set(result[key].concat(current[key]))) : [...result[key], ...current[key]] : current[key];
    } else if (isObject(result[key]) && isObject(current[key])) {
      result[key] = merge(result[key], current[key]);
    } else {
      result[key] = current[key] === void 0 ? merge.options.allowUndefinedOverrides ? current[key] : result[key] : current[key];
    }
  });
  return result;
}, {});
var defaultOptions = {
  allowUndefinedOverrides: true,
  mergeArrays: true,
  uniqueArrayItems: true
};
merge.options = defaultOptions;
merge.withOptions = (options, ...objects) => {
  merge.options = Object.assign(Object.assign({}, defaultOptions), options);
  const result = merge(...objects);
  merge.options = defaultOptions;
  return result;
};

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/errors.js
var SuperFormError = class _SuperFormError extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, _SuperFormError.prototype);
  }
};
var SchemaError = class _SchemaError extends SuperFormError {
  constructor(message2, path) {
    super((path && path.length ? `[${Array.isArray(path) ? path.join(".") : path}] ` : "") + message2);
    __publicField(this, "path");
    this.path = Array.isArray(path) ? path.join(".") : path;
    Object.setPrototypeOf(this, _SchemaError.prototype);
  }
};
function mapErrors(errors, shape) {
  var _a;
  const output = {};
  function addFormLevelError(error) {
    if (!("_errors" in output))
      output._errors = [];
    if (!Array.isArray(output._errors)) {
      if (typeof output._errors === "string")
        output._errors = [output._errors];
      else
        throw new SuperFormError("Form-level error was not an array.");
    }
    output._errors.push(error.message);
  }
  for (const error of errors) {
    if (!error.path || error.path.length == 1 && !error.path[0]) {
      addFormLevelError(error);
      continue;
    }
    const isLastIndexNumeric = /^\d$/.test(String(error.path[error.path.length - 1]));
    const objectError = !isLastIndexNumeric && ((_a = pathExists(shape, error.path.filter((p) => /\D/.test(String(p))))) == null ? void 0 : _a.value);
    const leaf = traversePath(output, error.path, ({ value, parent: parent2, key: key2 }) => {
      if (value === void 0)
        parent2[key2] = {};
      return parent2[key2];
    });
    if (!leaf) {
      addFormLevelError(error);
      continue;
    }
    const { parent, key } = leaf;
    if (objectError) {
      if (!(key in parent))
        parent[key] = {};
      if (!("_errors" in parent[key]))
        parent[key]._errors = [error.message];
      else
        parent[key]._errors.push(error.message);
    } else {
      if (!(key in parent))
        parent[key] = [error.message];
      else
        parent[key].push(error.message);
    }
  }
  return output;
}
function updateErrors(New, Previous, force) {
  if (force)
    return New;
  traversePaths(Previous, (errors) => {
    if (!Array.isArray(errors.value))
      return;
    errors.set(void 0);
  });
  traversePaths(New, (error) => {
    if (!Array.isArray(error.value))
      return;
    setPaths(Previous, [error.path], error.value);
  });
  return Previous;
}
function flattenErrors(errors) {
  return _flattenErrors(errors, []);
}
function _flattenErrors(errors, path) {
  const entries = Object.entries(errors);
  return entries.filter(([, value]) => value !== void 0).flatMap(([key, messages]) => {
    if (Array.isArray(messages) && messages.length > 0) {
      const currPath = path.concat([key]);
      return { path: mergePath(currPath), messages };
    } else {
      return _flattenErrors(errors[key], path.concat([key]));
    }
  });
}
function mergeDefaults(parsedData, defaults2) {
  if (!parsedData)
    return clone2(defaults2);
  return merge.withOptions({ mergeArrays: false }, defaults2, parsedData);
}
function replaceInvalidDefaults(Data, Defaults, _schema, Errors, preprocessed) {
  const defaultType = _schema.additionalProperties && typeof _schema.additionalProperties == "object" ? { __types: schemaInfo(_schema.additionalProperties, false, []).types } : void 0;
  const Types = defaultTypes(_schema);
  function Types_correctValue(dataValue, defValue, type) {
    const types = type.__types;
    if (!types.length || types.every((t) => t == "undefined" || t == "null" || t == "any")) {
      return dataValue;
    } else if (types.length == 1 && types[0] == "array" && !type.__items) {
      return dataValue;
    }
    const dateTypes = ["unix-time", "Date", "date"];
    for (const schemaType of types) {
      const defaultTypeValue = defaultValue(schemaType, void 0);
      const sameType = typeof dataValue === typeof defaultTypeValue || dateTypes.includes(schemaType) && dataValue instanceof Date;
      const sameExistance = sameType && dataValue === null === (defaultTypeValue === null);
      if (sameType && sameExistance) {
        return dataValue;
      } else if (type.__items) {
        return Types_correctValue(dataValue, defValue, type.__items);
      }
    }
    if (defValue === void 0 && types.includes("null")) {
      return null;
    }
    return defValue;
  }
  function Data_traverse() {
    traversePaths(Defaults, Defaults_traverseAndReplace);
    Errors_traverseAndReplace();
    return Data;
  }
  function Data_setValue(currentPath, newValue) {
    setPaths(Data, [currentPath], newValue);
  }
  function Errors_traverseAndReplace() {
    var _a;
    for (const error of Errors) {
      if (!error.path)
        continue;
      Defaults_traverseAndReplace({
        path: error.path,
        value: (_a = pathExists(Defaults, error.path)) == null ? void 0 : _a.value
      });
    }
  }
  function Defaults_traverseAndReplace(defaultPath) {
    const currentPath = defaultPath.path;
    if (!currentPath || !currentPath[0])
      return;
    if (typeof currentPath[0] === "string" && (preprocessed == null ? void 0 : preprocessed.includes(currentPath[0])))
      return;
    const dataPath = pathExists(Data, currentPath);
    if (!dataPath && defaultPath.value !== void 0 || dataPath && dataPath.value === void 0) {
      Data_setValue(currentPath, defaultPath.value);
    } else if (dataPath) {
      const defValue = defaultPath.value;
      const dataValue = dataPath.value;
      if (defValue !== void 0 && typeof dataValue === typeof defValue && dataValue === null === (defValue === null)) {
        return;
      }
      const typePath = currentPath.filter((p) => /\D/.test(String(p)));
      const pathTypes = traversePath(Types, typePath, (path) => {
        return "__items" in path.value ? path.value.__items : path.value;
      });
      if (!pathTypes) {
        throw new SchemaError("No types found for defaults", currentPath);
      }
      const fieldType = pathTypes.value ?? defaultType;
      if (!fieldType) {
        throw new SchemaError("No default value specified for field (can be undefined, but must be explicit)", currentPath);
      }
      Data_setValue(currentPath, Types_correctValue(dataValue, defValue, fieldType));
    }
  }
  {
    return Data_traverse();
  }
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/flash.js
import { browser } from "$app/environment";
function cancelFlash(options) {
  if (!options.flashMessage || !browser)
    return;
  if (!shouldSyncFlash(options))
    return;
  document.cookie = `flash=; Max-Age=0; Path=${options.flashMessage.cookiePath ?? "/"};`;
}
function shouldSyncFlash(options) {
  if (!options.flashMessage || !browser)
    return false;
  return options.syncFlashMessage;
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/superForm.js
import { applyAction, enhance } from "$app/forms";

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/customValidity.js
var noCustomValidityDataAttribute = "noCustomValidity";
async function updateCustomValidity(validityEl, errors) {
  if ("setCustomValidity" in validityEl) {
    validityEl.setCustomValidity("");
  }
  if (noCustomValidityDataAttribute in validityEl.dataset)
    return;
  setCustomValidity(validityEl, errors);
}
function setCustomValidityForm(formElement, errors) {
  for (const el of formElement.querySelectorAll("input,select,textarea,button")) {
    if (noCustomValidityDataAttribute in el.dataset) {
      continue;
    }
    const error = traversePath(errors, splitPath(el.name));
    setCustomValidity(el, error == null ? void 0 : error.value);
    if (error == null ? void 0 : error.value)
      return;
  }
}
function setCustomValidity(el, errors) {
  const message2 = errors && errors.length ? errors.join("\n") : "";
  el.setCustomValidity(message2);
  if (message2)
    el.reportValidity();
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/elements.js
var isElementInViewport = (el, topOffset = 0) => {
  const rect = el.getBoundingClientRect();
  return rect.top >= topOffset && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
var scrollToAndCenter = (el, offset = 1.125, behavior = "smooth") => {
  const elementRect = el.getBoundingClientRect();
  const absoluteElementTop = elementRect.top + window.pageYOffset;
  const top = absoluteElementTop - window.innerHeight / (2 * offset);
  window.scrollTo({ left: 0, top, behavior });
};
var immediateInputTypes = ["checkbox", "radio", "range", "file"];
function inputInfo(el) {
  const immediate = !!el && (el instanceof HTMLSelectElement || el instanceof HTMLInputElement && immediateInputTypes.includes(el.type));
  const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;
  const file = !!el && el instanceof HTMLInputElement && el.type == "file";
  return { immediate, multiple, file };
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/form.js
var FetchStatus;
(function(FetchStatus2) {
  FetchStatus2[FetchStatus2["Idle"] = 0] = "Idle";
  FetchStatus2[FetchStatus2["Submitting"] = 1] = "Submitting";
  FetchStatus2[FetchStatus2["Delayed"] = 2] = "Delayed";
  FetchStatus2[FetchStatus2["Timeout"] = 3] = "Timeout";
})(FetchStatus || (FetchStatus = {}));
var activeTimers = /* @__PURE__ */ new Set();
function Form(formElement, timers, options) {
  let state = FetchStatus.Idle;
  let delayedTimeout, timeoutTimeout;
  const Timers = activeTimers;
  function Timers_start() {
    Timers_clear();
    Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);
    delayedTimeout = window.setTimeout(() => {
      if (delayedTimeout && state == FetchStatus.Submitting)
        Timers_setState(FetchStatus.Delayed);
    }, options.delayMs);
    timeoutTimeout = window.setTimeout(() => {
      if (timeoutTimeout && state == FetchStatus.Delayed)
        Timers_setState(FetchStatus.Timeout);
    }, options.timeoutMs);
    Timers.add(Timers_clear);
  }
  function Timers_clear() {
    clearTimeout(delayedTimeout);
    clearTimeout(timeoutTimeout);
    delayedTimeout = timeoutTimeout = 0;
    Timers.delete(Timers_clear);
    Timers_setState(FetchStatus.Idle);
  }
  function Timers_clearAll() {
    Timers.forEach((t) => t());
    Timers.clear();
  }
  function Timers_setState(s) {
    state = s;
    timers.submitting.set(state >= FetchStatus.Submitting);
    timers.delayed.set(state >= FetchStatus.Delayed);
    timers.timeout.set(state >= FetchStatus.Timeout);
  }
  const ErrorTextEvents = formElement;
  function ErrorTextEvents__selectText(e) {
    const target = e.target;
    if (options.selectErrorText)
      target.select();
  }
  function ErrorTextEvents_addErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => {
      el.addEventListener("invalid", ErrorTextEvents__selectText);
    });
  }
  function ErrorTextEvents_removeErrorTextListeners() {
    if (!options.selectErrorText)
      return;
    ErrorTextEvents.querySelectorAll("input").forEach((el) => el.removeEventListener("invalid", ErrorTextEvents__selectText));
  }
  const Form2 = formElement;
  {
    ErrorTextEvents_addErrorTextListeners();
    const completed = (opts) => {
      if (!opts.clearAll)
        Timers_clear();
      else
        Timers_clearAll();
      if (!opts.cancelled)
        setTimeout(() => scrollToFirstError(Form2, options), 1);
    };
    onDestroy(() => {
      ErrorTextEvents_removeErrorTextListeners();
      completed({ cancelled: true });
    });
    return {
      submitting() {
        Timers_start();
      },
      completed,
      scrollToFirstError() {
        setTimeout(() => scrollToFirstError(Form2, options), 1);
      },
      isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
    };
  }
}
var scrollToFirstError = async (Form2, options) => {
  if (options.scrollToError == "off")
    return;
  const selector = options.errorSelector;
  if (!selector)
    return;
  await tick();
  let el;
  el = Form2.querySelector(selector);
  if (!el)
    return;
  el = el.querySelector(selector) ?? el;
  const nav = options.stickyNavbar ? document.querySelector(options.stickyNavbar) : null;
  if (typeof options.scrollToError != "string") {
    el.scrollIntoView(options.scrollToError);
  } else if (!isElementInViewport(el, (nav == null ? void 0 : nav.offsetHeight) ?? 0)) {
    scrollToAndCenter(el, void 0, options.scrollToError);
  }
  function Form_shouldAutoFocus(userAgent) {
    if (typeof options.autoFocusOnError === "boolean")
      return options.autoFocusOnError;
    else
      return !/iPhone|iPad|iPod|Android/i.test(userAgent);
  }
  if (!Form_shouldAutoFocus(navigator.userAgent))
    return;
  let focusEl;
  focusEl = el;
  if (!["INPUT", "SELECT", "BUTTON", "TEXTAREA"].includes(focusEl.tagName)) {
    focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
  }
  if (focusEl) {
    try {
      focusEl.focus({ preventScroll: true });
      if (options.selectErrorText && focusEl.tagName == "INPUT") {
        focusEl.select();
      }
    } catch (err) {
    }
  }
};

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/proxies.js
var defaultOptions2 = {
  trueStringValue: "true",
  dateFormat: "iso"
};
function booleanProxy(form, path, options) {
  return _stringProxy(form, path, "boolean", {
    ...defaultOptions2,
    ...options
  });
}
function intProxy(form, path, options) {
  return _stringProxy(form, path, "int", {
    ...defaultOptions2,
    ...options
  });
}
function numberProxy(form, path, options) {
  return _stringProxy(form, path, "number", {
    ...defaultOptions2,
    ...options
  });
}
function dateProxy(form, path, options) {
  return _stringProxy(form, path, "date", {
    ...defaultOptions2,
    dateFormat: (options == null ? void 0 : options.format) ?? "iso",
    empty: options == null ? void 0 : options.empty
  });
}
function stringProxy(form, path, options) {
  return _stringProxy(form, path, "string", {
    ...defaultOptions2,
    ...options
  });
}
function _stringProxy(form, path, type, options) {
  function toValue(value) {
    if (!value && options.empty !== void 0) {
      return options.empty === "null" ? null : options.empty === "zero" ? 0 : void 0;
    }
    if (typeof value === "number") {
      value = value.toString();
    }
    if (typeof value !== "string") {
      value = "";
    }
    const stringValue = value;
    if (type == "string")
      return stringValue;
    else if (type == "boolean")
      return !!stringValue;
    else if (type == "date")
      return new Date(stringValue);
    const numberToConvert = options.delimiter ? stringValue.replace(options.delimiter, ".") : stringValue;
    let num;
    if (numberToConvert === "" && options.empty == "zero")
      num = 0;
    else if (type == "number")
      num = parseFloat(numberToConvert);
    else
      num = parseInt(numberToConvert, 10);
    return num;
  }
  const isSuper = isSuperForm(form, options);
  const realProxy = isSuper ? superFieldProxy(form, path, { taint: options.taint }) : fieldProxy(form, path);
  let updatedValue = null;
  let initialized = false;
  const proxy = derived(realProxy, (value) => {
    if (!initialized) {
      initialized = true;
      if (options.initiallyEmptyIfZero && !value)
        return "";
    }
    if (updatedValue !== null) {
      const current = updatedValue;
      updatedValue = null;
      return current;
    }
    if (value === void 0 || value === null)
      return "";
    if (type == "string") {
      return value;
    } else if (type == "int" || type == "number") {
      if (value === "") {
        realProxy.set(0, isSuper ? { taint: false } : void 0);
      }
      if (typeof value === "number" && isNaN(value))
        return "";
      return String(value);
    } else if (type == "date") {
      const date = value;
      if (isNaN(date))
        return "";
      switch (options.dateFormat) {
        case "iso":
          return date.toISOString();
        case "date":
          return date.toISOString().slice(0, 10);
        case "datetime":
          return date.toISOString().slice(0, 16);
        case "time":
          return date.toISOString().slice(11, 16);
        case "date-utc":
          return UTCDate(date);
        case "datetime-utc":
          return UTCDate(date) + "T" + UTCTime(date);
        case "time-utc":
          return UTCTime(date);
        case "date-local":
          return localDate(date);
        case "datetime-local":
          return localDate(date) + "T" + localTime(date);
        case "time-local":
          return localTime(date);
      }
    } else {
      return value ? options.trueStringValue : "";
    }
  });
  return {
    subscribe: proxy.subscribe,
    set(val) {
      updatedValue = val;
      const newValue = toValue(updatedValue);
      realProxy.set(newValue);
    },
    update(updater) {
      realProxy.update((f) => {
        updatedValue = updater(String(f));
        const newValue = toValue(updatedValue);
        return newValue;
      });
    }
  };
}
function arrayProxy(superForm2, path, options) {
  const formErrors = fieldProxy(
    superForm2.errors,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    `${path}`
  );
  const onlyFieldErrors = derived(formErrors, ($errors) => {
    const output = [];
    for (const key in $errors) {
      if (key == "_errors")
        continue;
      output[key] = $errors[key];
    }
    return output;
  });
  function updateArrayErrors(errors, value) {
    for (const key in errors) {
      if (key == "_errors")
        continue;
      errors[key] = void 0;
    }
    if (value !== void 0) {
      for (const key in value) {
        errors[key] = value[key];
      }
    }
    return errors;
  }
  const fieldErrors = {
    subscribe: onlyFieldErrors.subscribe,
    update(upd) {
      formErrors.update(($errors) => (
        // @ts-expect-error Type is correct
        updateArrayErrors($errors, upd($errors))
      ));
    },
    set(value) {
      formErrors.update(($errors) => updateArrayErrors($errors, value));
    }
  };
  const values = superFieldProxy(superForm2, path, options);
  let lastLength = Array.isArray(get_store_value(values)) ? get_store_value(values).length : 0;
  values.subscribe(($values) => {
    const currentLength = Array.isArray($values) ? $values.length : 0;
    if (currentLength < lastLength) {
      superForm2.errors.update(($errors) => {
        const node = pathExists($errors, splitPath(path));
        if (!node)
          return $errors;
        for (const key in node.value) {
          if (Number(key) < currentLength)
            continue;
          delete node.value[key];
        }
        return $errors;
      }, { force: true });
    }
    lastLength = currentLength;
  });
  return {
    path,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    values,
    errors: fieldProxy(
      superForm2.errors,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      `${path}._errors`
    ),
    valueErrors: fieldErrors
  };
}
function formFieldProxy(superForm2, path, options) {
  const path2 = splitPath(path);
  const constraintsPath = path2.filter((p) => /\D/.test(String(p))).join(".");
  const taintedProxy = derived(superForm2.tainted, ($tainted) => {
    if (!$tainted)
      return $tainted;
    const taintedPath = traversePath($tainted, path2);
    return taintedPath ? taintedPath.value : void 0;
  });
  const tainted = {
    subscribe: taintedProxy.subscribe,
    update(upd) {
      superForm2.tainted.update(($tainted) => {
        if (!$tainted)
          $tainted = {};
        const output = traversePath($tainted, path2, (path3) => {
          if (!path3.value)
            path3.parent[path3.key] = {};
          return path3.parent[path3.key];
        });
        if (output)
          output.parent[output.key] = upd(output.value);
        return $tainted;
      });
    },
    set(value) {
      superForm2.tainted.update(($tainted) => {
        if (!$tainted)
          $tainted = {};
        const output = traversePath($tainted, path2, (path3) => {
          if (!path3.value)
            path3.parent[path3.key] = {};
          return path3.parent[path3.key];
        });
        if (output)
          output.parent[output.key] = value;
        return $tainted;
      });
    }
  };
  return {
    path,
    value: superFieldProxy(superForm2, path, options),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    errors: fieldProxy(superForm2.errors, path),
    constraints: fieldProxy(superForm2.constraints, constraintsPath),
    tainted
  };
}
function updateProxyField(obj, path, updater) {
  const output = traversePath(obj, path, ({ parent, key, value }) => {
    if (value === void 0)
      parent[key] = /\D/.test(key) ? {} : [];
    return parent[key];
  });
  if (output) {
    const newValue = updater(output.value);
    output.parent[output.key] = newValue;
  }
  return obj;
}
function superFieldProxy(superForm2, path, baseOptions) {
  const form = superForm2.form;
  const path2 = splitPath(path);
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data == null ? void 0 : data.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd, options) {
      form.update((data) => updateProxyField(data, path2, upd), options ?? baseOptions);
    },
    set(value, options) {
      form.update((data) => updateProxyField(data, path2, () => value), options ?? baseOptions);
    }
  };
}
function isSuperForm(form, options) {
  const isSuperForm2 = "form" in form;
  if (!isSuperForm2 && (options == null ? void 0 : options.taint) !== void 0) {
    throw new SuperFormError("If options.taint is set, the whole superForm object must be used as a proxy.");
  }
  return isSuperForm2;
}
function fieldProxy(form, path, options) {
  const path2 = splitPath(path);
  if (isSuperForm(form, options)) {
    return superFieldProxy(form, path, options);
  }
  const proxy = derived(form, ($form) => {
    const data = traversePath($form, path2);
    return data == null ? void 0 : data.value;
  });
  return {
    subscribe(...params) {
      const unsub = proxy.subscribe(...params);
      return () => unsub();
    },
    update(upd) {
      form.update((data) => updateProxyField(data, path2, upd));
    },
    set(value) {
      form.update((data) => updateProxyField(data, path2, () => value));
    }
  };
}
function localDate(date) {
  return date.getFullYear() + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0");
}
function localTime(date) {
  return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0");
}
function UTCDate(date) {
  return date.getUTCFullYear() + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0");
}
function UTCTime(date) {
  return String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0");
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/client/superForm.js
var formIds = /* @__PURE__ */ new WeakMap();
var initialForms = /* @__PURE__ */ new WeakMap();
var defaultOnError = (event) => {
  console.warn("Unhandled Superform error, use onError event to handle it:", event.result.error);
};
var defaultFormOptions = {
  applyAction: true,
  invalidateAll: true,
  resetForm: true,
  autoFocusOnError: "detect",
  scrollToError: "smooth",
  errorSelector: '[aria-invalid="true"],[data-invalid]',
  selectErrorText: false,
  stickyNavbar: void 0,
  taintedMessage: false,
  onSubmit: void 0,
  onResult: void 0,
  onUpdate: void 0,
  onUpdated: void 0,
  onError: defaultOnError,
  dataType: "form",
  validators: void 0,
  customValidity: false,
  clearOnSubmit: "errors-and-message",
  delayMs: 500,
  timeoutMs: 8e3,
  multipleSubmits: "prevent",
  SPA: void 0,
  validationMethod: "auto"
};
function multipleFormIdError(id) {
  return `Duplicate form id's found: "${id}". Multiple forms will receive the same data. Use the id option to differentiate between them, or if this is intended, set the warnings.duplicateId option to false in superForm to disable this warning. More information: https://superforms.rocks/concepts/multiple-forms`;
}
var legacyMode = false;
try {
  if (SUPERFORMS_LEGACY)
    legacyMode = true;
} catch {
}
function superForm(form, formOptions) {
  var _a;
  let initialForm;
  let options = formOptions ?? {};
  let initialValidator = void 0;
  {
    if (options.legacy ?? legacyMode) {
      if (options.resetForm === void 0)
        options.resetForm = false;
      if (options.taintedMessage === void 0)
        options.taintedMessage = true;
    }
    initialValidator = options.validators;
    options = {
      ...defaultFormOptions,
      ...options
    };
    if (options.SPA && options.validators === void 0) {
      console.warn("No validators set for superForm in SPA mode. Add a validation adapter to the validators option, or set it to false to disable this warning.");
    }
    if (!form) {
      throw new SuperFormError("No form data sent to superForm. Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. Alternatively, an object with default values for the form can also be used, but then constraints won't be available.");
    }
    if (!Context_isValidationObject(form)) {
      form = {
        id: options.id ?? "",
        valid: false,
        posted: false,
        errors: {},
        data: form
      };
    }
    form = form;
    const _initialFormId = options.id ?? form.id;
    const _currentPage = get_store_value(page);
    if (browser2 && ((_a = options.warnings) == null ? void 0 : _a.duplicateId) !== false) {
      if (!formIds.has(_currentPage)) {
        formIds.set(_currentPage, /* @__PURE__ */ new Set([_initialFormId]));
      } else {
        const currentForms = formIds.get(_currentPage);
        if (currentForms == null ? void 0 : currentForms.has(_initialFormId)) {
          console.warn(multipleFormIdError(_initialFormId));
        } else {
          currentForms == null ? void 0 : currentForms.add(_initialFormId);
        }
      }
    }
    if (!initialForms.has(form)) {
      initialForms.set(form, form);
    }
    initialForm = initialForms.get(form);
    if (typeof initialForm.valid !== "boolean") {
      throw new SuperFormError("A non-validation object was passed to superForm. It should be an object of type SuperValidated, usually returned from superValidate.");
    }
    if (!browser2 && _currentPage.form && typeof _currentPage.form === "object") {
      const postedData = _currentPage.form;
      for (const postedForm of Context_findValidationForms(postedData).reverse()) {
        if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {
          initialForms.set(postedData, postedData);
          const pageDataForm = form;
          form = postedForm;
          form.constraints = pageDataForm.constraints;
          form.shape = pageDataForm.shape;
          if (form.valid && options.resetForm && (options.resetForm === true || options.resetForm())) {
            form = clone2(pageDataForm);
            form.message = clone2(postedForm.message);
          }
          break;
        }
      }
    } else {
      form = clone2(initialForm);
    }
    onDestroy(() => {
      var _a2;
      Unsubscriptions_unsubscribe();
      NextChange_clear();
      for (const events of Object.values(formEvents)) {
        events.length = 0;
      }
      (_a2 = formIds.get(_currentPage)) == null ? void 0 : _a2.delete(_initialFormId);
    });
    if (options.dataType !== "json") {
      const checkForNestedData = (key, value) => {
        if (!value || typeof value !== "object")
          return;
        if (Array.isArray(value)) {
          if (value.length > 0)
            checkForNestedData(key, value[0]);
        } else if (!(value instanceof Date) && !(value instanceof File) && (!browser2 || !(value instanceof FileList))) {
          throw new SuperFormError(`Object found in form field "${key}". Set the dataType option to "json" and add use:enhance to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`);
        }
      };
      for (const [key, value] of Object.entries(form.data)) {
        checkForNestedData(key, value);
      }
    }
  }
  const __data = {
    formId: form.id,
    form: clone2(form.data),
    constraints: form.constraints ?? {},
    posted: form.posted,
    errors: clone2(form.errors),
    message: clone2(form.message),
    tainted: void 0,
    valid: form.valid,
    submitting: false,
    shape: form.shape
  };
  const Data = __data;
  const FormId = writable(options.id ?? form.id);
  const Context = {};
  function Context_findValidationForms(data) {
    const forms = Object.values(data).filter((v) => Context_isValidationObject(v) !== false);
    return forms;
  }
  function Context_isValidationObject(object) {
    if (!object || typeof object !== "object")
      return false;
    if (!("valid" in object && "errors" in object && typeof object.valid === "boolean")) {
      return false;
    }
    return "id" in object && typeof object.id === "string" ? object.id : false;
  }
  const _formData = writable(form.data);
  const Form2 = {
    subscribe: _formData.subscribe,
    set: (value, options2 = {}) => {
      const newData = clone2(value);
      Tainted_update(newData, options2.taint ?? true);
      return _formData.set(newData);
    },
    update: (updater, options2 = {}) => {
      return _formData.update((value) => {
        const newData = updater(value);
        Tainted_update(newData, options2.taint ?? true);
        return newData;
      });
    }
  };
  async function Form_validate(opts = {}) {
    const dataToValidate = opts.formData ?? Data.form;
    let errors = {};
    let status;
    const validator = opts.adapter ?? options.validators;
    if (typeof validator == "object") {
      if (validator != initialValidator && !("jsonSchema" in validator)) {
        throw new SuperFormError("Client validation adapter found in options.validators. A full adapter must be used when changing validators dynamically.");
      }
      status = await validator.validate(dataToValidate);
      if (!status.success) {
        errors = mapErrors(status.issues, validator.shape ?? Data.shape ?? {});
      } else if (opts.recheckValidData !== false) {
        return Form_validate({ ...opts, recheckValidData: false });
      }
    } else {
      status = { success: true, data: {} };
    }
    const data = { ...Data.form, ...dataToValidate, ...status.success ? status.data : {} };
    return {
      valid: status.success,
      posted: false,
      errors,
      data,
      constraints: Data.constraints,
      message: void 0,
      id: Data.formId,
      shape: Data.shape
    };
  }
  function Form__changeEvent(event) {
    if (!options.onChange || !event.paths.length || event.type == "blur")
      return;
    let changeEvent;
    const paths = event.paths.map(mergePath);
    if (event.type && event.paths.length == 1 && event.formElement && event.target instanceof Element) {
      changeEvent = {
        path: paths[0],
        paths,
        formElement: event.formElement,
        target: event.target,
        set(path, value, options2) {
          fieldProxy({ form: Form2 }, path, options2).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form2, path));
        }
      };
    } else {
      changeEvent = {
        paths,
        target: void 0,
        set(path, value, options2) {
          fieldProxy({ form: Form2 }, path, options2).set(value);
        },
        get(path) {
          return get_store_value(fieldProxy(Form2, path));
        }
      };
    }
    options.onChange(changeEvent);
  }
  async function Form_clientValidation(event, force = false, adapter) {
    if (event) {
      if (options.validators == "clear") {
        Errors.update(($errors) => {
          setPaths($errors, event.paths, void 0);
          return $errors;
        });
      }
      setTimeout(() => Form__changeEvent(event));
    }
    if (!event || !options.validators || options.validators == "clear")
      return;
    if (!force) {
      if (options.validationMethod == "onsubmit" || options.validationMethod == "submit-only") {
        return;
      }
      if (options.validationMethod == "onblur" && event.type == "input")
        return;
      if (options.validationMethod == "oninput" && event.type == "blur")
        return;
    }
    const result = await Form_validate({ adapter });
    if (result.valid && (event.immediate || event.type != "input")) {
      Form2.set(result.data, { taint: "ignore" });
    }
    await tick();
    Form__displayNewErrors(result.errors, event, force);
    return result;
  }
  async function Form__displayNewErrors(errors, event, force) {
    const { type, immediate, multiple, paths } = event;
    const previous = Data.errors;
    const output = {};
    const validity = /* @__PURE__ */ new Map();
    const formElement = event.formElement ?? EnhancedForm;
    if (options.customValidity && formElement) {
      for (const path of event.paths) {
        const name = CSS.escape(mergePath(path));
        const el = formElement.querySelector(`[name="${name}"]`);
        if (el) {
          const message2 = "validationMessage" in el ? String(el.validationMessage) : "";
          validity.set(path.join(), { el, message: message2 });
          updateCustomValidity(el, void 0);
        }
      }
    }
    traversePaths(errors, (error) => {
      if (!Array.isArray(error.value))
        return;
      let joinedPath = error.path.join(".");
      if (joinedPath.endsWith("._errors")) {
        joinedPath = joinedPath.substring(0, -8);
      }
      function addError() {
        setPaths(output, [error.path], error.value);
        if (options.customValidity && isEventError && validity.has(joinedPath)) {
          const { el, message: message2 } = validity.get(joinedPath);
          if (message2 != error.value) {
            updateCustomValidity(el, error.value);
            validity.clear();
          }
        }
      }
      if (force)
        return addError();
      const isEventError = error.value && paths.map((path) => path.join(".")).some((path) => path.startsWith(joinedPath));
      if (isEventError && options.validationMethod == "oninput")
        return addError();
      if (immediate && !multiple && isEventError)
        return addError();
      if (multiple) {
        const errorPath = pathExists(get_store_value(Errors), error.path.slice(0, -1));
        if ((errorPath == null ? void 0 : errorPath.value) && typeof (errorPath == null ? void 0 : errorPath.value) == "object") {
          for (const errors2 of Object.values(errorPath.value)) {
            if (Array.isArray(errors2)) {
              return addError();
            }
          }
        }
      }
      const previousError = pathExists(previous, error.path);
      if (previousError && previousError.key in previousError.parent) {
        return addError();
      }
      const lastPath = error.path[error.path.length - 1];
      const isObjectError = lastPath == "_errors";
      if (isObjectError) {
        if (options.validationMethod == "oninput" || type == "blur" && Tainted_hasBeenTainted(mergePath(error.path.slice(0, -1)))) {
          return addError();
        }
      } else {
        if (type == "blur" && isEventError) {
          return addError();
        }
      }
    });
    Errors.set(output);
  }
  function Form_set(data, options2 = {}) {
    if (options2.keepFiles) {
      traversePaths(Data.form, (info) => {
        if ((!browser2 || !(info.parent instanceof FileList)) && (info.value instanceof File || browser2 && info.value instanceof FileList)) {
          const dataPath = pathExists(data, info.path);
          if (!dataPath || !(dataPath.key in dataPath.parent)) {
            setPaths(data, [info.path], info.value);
          }
        }
      });
    }
    return Form2.set(data, options2);
  }
  function Form_shouldReset(validForm, successActionResult) {
    return validForm && successActionResult && options.resetForm && (options.resetForm === true || options.resetForm());
  }
  async function Form_updateFromValidation(form2, successResult) {
    if (form2.valid && successResult && Form_shouldReset(form2.valid, successResult)) {
      Form_reset({ message: form2.message, posted: true });
    } else {
      rebind(form2, successResult, void 0, true);
    }
    if (formEvents.onUpdated.length) {
      await tick();
    }
    for (const event of formEvents.onUpdated) {
      event({ form: form2 });
    }
  }
  function Form_reset(opts = {}) {
    const resetData = clone2(initialForm);
    resetData.data = { ...resetData.data, ...opts.data };
    if (opts.id !== void 0)
      resetData.id = opts.id;
    rebind(resetData, true, opts.message, false, opts.posted);
  }
  const Form_updateFromActionResult = async (result) => {
    if (result.type == "error") {
      throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
    }
    if (result.type == "redirect") {
      if (Form_shouldReset(true, true))
        Form_reset({ posted: true });
      return;
    }
    if (typeof result.data !== "object") {
      throw new SuperFormError("Non-object validation data returned from ActionResult.");
    }
    const forms = Context_findValidationForms(result.data);
    if (!forms.length) {
      throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
    }
    for (const newForm of forms) {
      if (newForm.id !== Data.formId)
        continue;
      await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);
    }
  };
  const Message = writable(__data.message);
  const Constraints = writable(__data.constraints);
  const Posted = writable(__data.posted);
  const Shape = writable(__data.shape);
  const _errors = writable(form.errors);
  const Errors = {
    subscribe: _errors.subscribe,
    set(value, options2) {
      return _errors.set(updateErrors(value, Data.errors, options2 == null ? void 0 : options2.force));
    },
    update(updater, options2) {
      return _errors.update((value) => {
        return updateErrors(updater(value), Data.errors, options2 == null ? void 0 : options2.force);
      });
    },
    /**
     * To work with client-side validation, errors cannot be deleted but must
     * be set to undefined, to know where they existed before (tainted+error check in oninput)
     */
    clear: () => void 0
  };
  let NextChange = null;
  function NextChange_setHtmlEvent(event) {
    NextChange = event;
    setTimeout(() => {
      Form_clientValidation(NextChange);
    }, 0);
  }
  function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {
    if (NextChange === null) {
      NextChange = { paths: [] };
    }
    NextChange.type = event;
    NextChange.immediate = immediate;
    NextChange.multiple = multiple;
    NextChange.formElement = formElement;
    NextChange.target = target;
  }
  function NextChange_paths() {
    return (NextChange == null ? void 0 : NextChange.paths) ?? [];
  }
  function NextChange_clear() {
    NextChange = null;
  }
  const Tainted = {
    state: writable(),
    message: options.taintedMessage,
    clean: clone2(form.data)
    // Important to clone form.data, so it's not comparing the same object,
  };
  function Tainted_enable() {
    options.taintedMessage = Tainted.message;
  }
  function Tainted_currentState() {
    return Tainted.state;
  }
  function Tainted_hasBeenTainted(path) {
    if (!Data.tainted)
      return false;
    if (!path)
      return !!Data.tainted;
    const field = pathExists(Data.tainted, splitPath(path));
    return !!field && field.key in field.parent;
  }
  function Tainted_isTainted(path) {
    if (typeof path === "boolean")
      return path;
    if (typeof path === "object")
      return Tainted__isObjectTainted(path);
    if (!Data.tainted)
      return false;
    if (!path)
      return Tainted__isObjectTainted(Data.tainted);
    const field = pathExists(Data.tainted, splitPath(path));
    return Tainted__isObjectTainted(field == null ? void 0 : field.value);
  }
  function Tainted__isObjectTainted(obj) {
    if (!obj)
      return false;
    if (typeof obj === "object") {
      for (const obj2 of Object.values(obj)) {
        if (Tainted__isObjectTainted(obj2))
          return true;
      }
    }
    return obj === true;
  }
  function Tainted_update(newData, taintOptions) {
    if (taintOptions == "ignore")
      return;
    const paths = comparePaths(newData, Data.form);
    if (paths.length) {
      if (taintOptions == "untaint-all" || taintOptions == "untaint-form") {
        Tainted.state.set(void 0);
      } else {
        Tainted.state.update((tainted) => {
          if (!tainted)
            tainted = {};
          setPaths(tainted, paths, (path, data) => {
            const currentValue = traversePath(newData, path);
            const cleanPath = traversePath(Tainted.clean, path);
            return currentValue && cleanPath && currentValue.value === cleanPath.value ? void 0 : taintOptions === true ? true : taintOptions === "untaint" ? void 0 : data.value;
          });
          return tainted;
        });
      }
    }
    NextChange_setHtmlEvent({ paths });
  }
  function Tainted_set(tainted, newClean) {
    Tainted.state.set(tainted);
    if (newClean)
      Tainted.clean = newClean;
  }
  const Submitting = writable(false);
  const Delayed = writable(false);
  const Timeout = writable(false);
  const Unsubscriptions = [
    // eslint-disable-next-line dci-lint/private-role-access
    Tainted.state.subscribe((tainted) => __data.tainted = clone2(tainted)),
    // eslint-disable-next-line dci-lint/private-role-access
    Form2.subscribe((form2) => __data.form = clone2(form2)),
    // eslint-disable-next-line dci-lint/private-role-access
    Errors.subscribe((errors) => __data.errors = clone2(errors)),
    FormId.subscribe((id) => __data.formId = id),
    Constraints.subscribe((constraints2) => __data.constraints = constraints2),
    Posted.subscribe((posted) => __data.posted = posted),
    Message.subscribe((message2) => __data.message = message2),
    Submitting.subscribe((submitting) => __data.submitting = submitting),
    Shape.subscribe((shape) => __data.shape = shape)
  ];
  function Unsubscriptions_add(func) {
    Unsubscriptions.push(func);
  }
  function Unsubscriptions_unsubscribe() {
    Unsubscriptions.forEach((unsub) => unsub());
  }
  const AllErrors = derived(Errors, ($errors) => $errors ? flattenErrors($errors) : []);
  let EnhancedForm;
  options.taintedMessage = void 0;
  function rebind(form2, untaint, message2, keepFiles, posted) {
    if (untaint) {
      Tainted_set(typeof untaint === "boolean" ? void 0 : untaint, form2.data);
    }
    message2 = message2 ?? form2.message;
    Form_set(form2.data, { taint: "ignore", keepFiles });
    Message.set(message2);
    Errors.set(form2.errors);
    FormId.set(form2.id);
    Posted.set(posted ?? form2.posted);
    if (form2.constraints)
      Constraints.set(form2.constraints);
    if (form2.shape)
      Shape.set(form2.shape);
    __data.valid = form2.valid;
    if (options.flashMessage && shouldSyncFlash(options)) {
      const flash = options.flashMessage.module.getFlash(page);
      if (message2 && get_store_value(flash) === void 0) {
        flash.set(message2);
      }
    }
  }
  const formEvents = {
    onSubmit: options.onSubmit ? [options.onSubmit] : [],
    onResult: options.onResult ? [options.onResult] : [],
    onUpdate: options.onUpdate ? [options.onUpdate] : [],
    onUpdated: options.onUpdated ? [options.onUpdated] : [],
    onError: options.onError ? [options.onError] : []
  };
  if (browser2) {
    const defaultMessage = "Leave page? Changes that you made may not be saved.";
    let forceRedirection = false;
    beforeNavigate(async (nav) => {
      if (options.taintedMessage && !Data.submitting && !forceRedirection) {
        if (Tainted_isTainted()) {
          const { taintedMessage } = options;
          nav.cancel();
          if (nav.type === "leave")
            return;
          const isTaintedFunction = typeof taintedMessage === "function";
          const message2 = isTaintedFunction || taintedMessage === true ? defaultMessage : taintedMessage;
          const confirmFunction = isTaintedFunction ? taintedMessage : () => window.confirm(message2);
          let shouldRedirect;
          try {
            shouldRedirect = await confirmFunction();
          } catch {
            shouldRedirect = false;
          }
          if (shouldRedirect && nav.to) {
            try {
              forceRedirection = true;
              await goto(nav.to.url, { ...nav.to.params });
              return;
            } finally {
              forceRedirection = false;
            }
          }
        }
      }
    });
    Unsubscriptions_add(page.subscribe(async (pageUpdate) => {
      if (!options.applyAction)
        return;
      if (options.SPA) {
        await new Promise((r) => setTimeout(r, 0));
      }
      const successResult = pageUpdate.status >= 200 && pageUpdate.status < 300;
      if (pageUpdate.form && typeof pageUpdate.form === "object") {
        const actionData = pageUpdate.form;
        if (actionData.type == "error")
          return;
        for (const newForm of Context_findValidationForms(actionData)) {
          const isInitial = initialForms.has(newForm);
          if (newForm.id !== Data.formId || isInitial) {
            continue;
          }
          initialForms.set(newForm, newForm);
          await Form_updateFromValidation(newForm, successResult);
        }
      } else if (pageUpdate.data && typeof pageUpdate.data === "object") {
        for (const newForm of Context_findValidationForms(pageUpdate.data)) {
          const isInitial = initialForms.has(newForm);
          if (newForm.id !== Data.formId || isInitial) {
            continue;
          }
          rebind(newForm, successResult, void 0, true);
        }
      }
    }));
  }
  return {
    form: Form2,
    formId: FormId,
    errors: Errors,
    message: Message,
    constraints: Constraints,
    tainted: Tainted_currentState(),
    submitting: readonly(Submitting),
    delayed: readonly(Delayed),
    timeout: readonly(Timeout),
    options,
    capture() {
      return {
        valid: Data.valid,
        posted: Data.posted,
        errors: Data.errors,
        data: Data.form,
        constraints: Data.constraints,
        message: Data.message,
        id: Data.formId,
        tainted: Data.tainted,
        shape: Data.shape
      };
    },
    restore: (snapshot) => {
      rebind(snapshot, snapshot.tainted ?? true);
    },
    async validate(path, opts = {}) {
      if (!options.validators) {
        throw new SuperFormError("options.validators must be set to use the validate method.");
      }
      if (opts.update === void 0)
        opts.update = true;
      if (opts.taint === void 0)
        opts.taint = false;
      if (typeof opts.errors == "string")
        opts.errors = [opts.errors];
      let data;
      const splittedPath = splitPath(path);
      if ("value" in opts) {
        if (opts.update === true || opts.update === "value") {
          Form2.update(($form) => {
            setPaths($form, [splittedPath], opts.value);
            return $form;
          }, { taint: opts.taint });
          data = Data.form;
        } else {
          data = clone2(Data.form);
          setPaths(data, [splittedPath], opts.value);
        }
      } else {
        data = Data.form;
      }
      const result = await Form_validate({ formData: data });
      const error = pathExists(result.errors, splittedPath);
      if (error && error.value && opts.errors) {
        error.value = opts.errors;
      }
      if (opts.update === true || opts.update == "errors") {
        Errors.update(($errors) => {
          setPaths($errors, [splittedPath], error == null ? void 0 : error.value);
          return $errors;
        });
      }
      return error == null ? void 0 : error.value;
    },
    async validateForm(opts = {}) {
      if (!options.validators && !opts.schema) {
        throw new SuperFormError("options.validators or the schema option must be set to use the validateForm method.");
      }
      const result = opts.update ? await Form_clientValidation({ paths: [] }, true, opts.schema) : Form_validate({ adapter: opts.schema });
      if (opts.update && EnhancedForm) {
        setTimeout(() => {
          if (EnhancedForm)
            scrollToFirstError(EnhancedForm, {
              ...options,
              scrollToError: opts.focusOnError === false ? "off" : options.scrollToError
            });
        }, 1);
      }
      return result || Form_validate({ adapter: opts.schema });
    },
    allErrors: AllErrors,
    posted: Posted,
    reset(options2) {
      return Form_reset({
        message: (options2 == null ? void 0 : options2.keepMessage) ? Data.message : void 0,
        data: options2 == null ? void 0 : options2.data,
        id: options2 == null ? void 0 : options2.id
      });
    },
    submit(submitter) {
      const form2 = EnhancedForm ? EnhancedForm : submitter ? submitter.closest("form") : void 0;
      if (!form2) {
        throw new SuperFormError("use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.");
      }
      const isSubmitButton = submitter && (submitter instanceof HTMLButtonElement && submitter.type == "submit" || submitter instanceof HTMLInputElement && ["submit", "image"].includes(submitter.type));
      form2.requestSubmit(isSubmitButton ? submitter : void 0);
    },
    isTainted: Tainted_isTainted,
    ///// Custom use:enhance ////////////////////////////////////////
    // @DCI-context
    enhance(FormElement, events) {
      EnhancedForm = FormElement;
      if (events) {
        if (events.onError) {
          if (options.onError === "apply") {
            throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
          } else if (events.onError === "apply") {
            throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
          }
          formEvents.onError.push(events.onError);
        }
        if (events.onResult)
          formEvents.onResult.push(events.onResult);
        if (events.onSubmit)
          formEvents.onSubmit.push(events.onSubmit);
        if (events.onUpdate)
          formEvents.onUpdate.push(events.onUpdate);
        if (events.onUpdated)
          formEvents.onUpdated.push(events.onUpdated);
      }
      Tainted_enable();
      let lastInputChange;
      async function onInput(e) {
        const info = inputInfo(e.target);
        if (info.immediate && !info.file)
          await new Promise((r) => setTimeout(r, 0));
        lastInputChange = NextChange_paths();
        NextChange_additionalEventInformation("input", info.immediate, info.multiple, FormElement, e.target ?? void 0);
      }
      async function onBlur(e) {
        if (Data.submitting)
          return;
        if (!lastInputChange || NextChange_paths() != lastInputChange) {
          return;
        }
        const info = inputInfo(e.target);
        if (info.immediate && !info.file)
          await new Promise((r) => setTimeout(r, 0));
        Form_clientValidation({
          paths: lastInputChange,
          immediate: info.multiple,
          multiple: info.multiple,
          type: "blur",
          formElement: FormElement,
          target: e.target ?? void 0
        });
        lastInputChange = void 0;
      }
      FormElement.addEventListener("focusout", onBlur);
      FormElement.addEventListener("input", onInput);
      onDestroy(() => {
        FormElement.removeEventListener("focusout", onBlur);
        FormElement.removeEventListener("input", onInput);
        EnhancedForm = void 0;
      });
      const htmlForm = Form(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options);
      let currentRequest;
      return enhance(FormElement, async (submitParams) => {
        var _a2, _b;
        let jsonData = void 0;
        let validationAdapter = options.validators;
        const submit = {
          ...submitParams,
          jsonData(data) {
            if (options.dataType !== "json") {
              throw new SuperFormError("options.dataType must be set to 'json' to use jsonData.");
            }
            jsonData = data;
          },
          validators(adapter) {
            validationAdapter = adapter;
          }
        };
        const _submitCancel = submit.cancel;
        let cancelled = false;
        function cancel(resetTimers = true) {
          cancelled = true;
          if (resetTimers && htmlForm.isSubmitting()) {
            htmlForm.completed({ cancelled });
          }
          return _submitCancel();
        }
        submit.cancel = cancel;
        if (htmlForm.isSubmitting() && options.multipleSubmits == "prevent") {
          cancel(false);
        } else {
          if (htmlForm.isSubmitting() && options.multipleSubmits == "abort") {
            if (currentRequest)
              currentRequest.abort();
          }
          htmlForm.submitting();
          currentRequest = submit.controller;
          for (const event of formEvents.onSubmit) {
            await event(submit);
          }
        }
        if (cancelled) {
          if (options.flashMessage)
            cancelFlash(options);
        } else {
          const noValidate = !options.SPA && (FormElement.noValidate || (submit.submitter instanceof HTMLButtonElement || submit.submitter instanceof HTMLInputElement) && submit.submitter.formNoValidate);
          let validation = void 0;
          const validateForm = async () => {
            return await Form_validate({ adapter: validationAdapter });
          };
          if (!noValidate) {
            validation = await validateForm();
            if (!validation.valid) {
              cancel(false);
              const result = {
                type: "failure",
                status: (typeof options.SPA === "boolean" ? void 0 : (_a2 = options.SPA) == null ? void 0 : _a2.failStatus) ?? 400,
                data: { form: validation }
              };
              setTimeout(() => validationResponse({ result }), 0);
            }
          }
          if (!cancelled) {
            switch (options.clearOnSubmit) {
              case "errors-and-message":
                Errors.clear();
                Message.set(void 0);
                break;
              case "errors":
                Errors.clear();
                break;
              case "message":
                Message.set(void 0);
                break;
            }
            if (options.flashMessage && (options.clearOnSubmit == "errors-and-message" || options.clearOnSubmit == "message") && shouldSyncFlash(options)) {
              options.flashMessage.module.getFlash(page).set(void 0);
            }
            const submitData = "formData" in submit ? submit.formData : submit.data;
            lastInputChange = void 0;
            if (options.SPA) {
              cancel(false);
              if (!validation)
                validation = await validateForm();
              const validationResult = { ...validation, posted: true };
              const result = {
                type: validationResult.valid ? "success" : "failure",
                status: validationResult.valid ? 200 : typeof options.SPA == "object" ? (_b = options.SPA) == null ? void 0 : _b.failStatus : 400,
                data: { form: validationResult }
              };
              setTimeout(() => validationResponse({ result }), 0);
            } else if (options.dataType === "json") {
              if (!validation)
                validation = await validateForm();
              const postData = clone2(jsonData ?? validation.data);
              traversePaths(postData, (data) => {
                if (data.value instanceof File) {
                  const key = "__superform_file_" + mergePath(data.path);
                  submitData.append(key, data.value);
                  return data.set(void 0);
                } else if (Array.isArray(data.value) && data.value.length && data.value.every((v) => v instanceof File)) {
                  const key = "__superform_files_" + mergePath(data.path);
                  for (const file of data.value) {
                    submitData.append(key, file);
                  }
                  return data.set(void 0);
                }
              });
              Object.keys(postData).forEach((key) => {
                if (typeof submitData.get(key) === "string") {
                  submitData.delete(key);
                }
              });
              const chunks = chunkSubstr(stringify(postData), options.jsonChunkSize ?? 5e5);
              for (const chunk of chunks) {
                submitData.append("__superform_json", chunk);
              }
            }
            if (!options.SPA && !submitData.has("__superform_id")) {
              const id = Data.formId;
              if (id !== void 0)
                submitData.set("__superform_id", id);
            }
          }
        }
        function chunkSubstr(str, size) {
          const numChunks = Math.ceil(str.length / size);
          const chunks = new Array(numChunks);
          for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
            chunks[i] = str.substring(o, o + size);
          }
          return chunks;
        }
        async function validationResponse(event) {
          var _a3;
          const result = event.result.type ? event.result : {
            type: "error",
            status: 500,
            error: event.result
          };
          currentRequest = null;
          let cancelled2 = false;
          const data = {
            result,
            formEl: FormElement,
            formElement: FormElement,
            cancel: () => cancelled2 = true
          };
          for (const event2 of formEvents.onResult) {
            await event2(data);
          }
          if (!cancelled2) {
            if ((result.type === "success" || result.type == "failure") && result.data) {
              const forms = Context_findValidationForms(result.data);
              if (!forms.length) {
                throw new SuperFormError("No form data returned from ActionResult. Make sure you return { form } in the form actions.");
              }
              for (const newForm of forms) {
                if (newForm.id !== Data.formId)
                  continue;
                const data2 = {
                  form: newForm,
                  formEl: FormElement,
                  formElement: FormElement,
                  cancel: () => cancelled2 = true
                };
                for (const event2 of formEvents.onUpdate) {
                  await event2(data2);
                }
                if (!cancelled2) {
                  if (options.customValidity) {
                    setCustomValidityForm(FormElement, data2.form.errors);
                  }
                  if (Form_shouldReset(data2.form.valid, result.type == "success")) {
                    data2.formElement.querySelectorAll('input[type="file"]').forEach((e) => e.value = "");
                  }
                }
              }
            }
            if (!cancelled2) {
              if (result.type !== "error") {
                if (result.type === "success" && options.invalidateAll) {
                  await invalidateAll();
                }
                if (options.applyAction) {
                  await applyAction(result);
                } else {
                  await Form_updateFromActionResult(result);
                }
              } else {
                if (options.applyAction) {
                  if (options.onError == "apply") {
                    await applyAction(result);
                  } else {
                    const failResult = {
                      type: "failure",
                      status: Math.floor(result.status || 500),
                      data: result
                    };
                    await applyAction(failResult);
                  }
                }
                if (options.onError !== "apply") {
                  const data2 = { result, message: Message };
                  for (const onErrorEvent of formEvents.onError) {
                    if (onErrorEvent !== "apply" && (onErrorEvent != defaultOnError || !((_a3 = options.flashMessage) == null ? void 0 : _a3.onError))) {
                      await onErrorEvent(data2);
                    }
                  }
                }
              }
              if (options.flashMessage) {
                if (result.type == "error" && options.flashMessage.onError) {
                  await options.flashMessage.onError({
                    result,
                    flashMessage: options.flashMessage.module.getFlash(page)
                  });
                }
              }
            }
          }
          if (cancelled2 && options.flashMessage) {
            cancelFlash(options);
          }
          if (cancelled2 || result.type != "redirect") {
            htmlForm.completed({ cancelled: cancelled2 });
          } else {
            const unsub = navigating.subscribe(($nav) => {
              if ($nav)
                return;
              setTimeout(() => {
                try {
                  if (unsub)
                    unsub();
                } catch {
                }
              });
              if (htmlForm.isSubmitting()) {
                htmlForm.completed({ cancelled: cancelled2, clearAll: true });
              }
            });
          }
        }
        return validationResponse;
      });
    }
  };
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/jsonSchema/schemaShape.js
function schemaShape(schema, path = []) {
  const output = _schemaShape(schema, path);
  if (!output)
    throw new SchemaError("No shape could be created for schema.", path);
  return output;
}
function _schemaShape(schema, path) {
  if (typeof schema === "boolean") {
    throw new SchemaError("Schema cannot be defined as boolean", path);
  }
  const info = schemaInfo(schema, false, path);
  if (info.array || info.union) {
    const arr = info.array || [];
    const union = info.union || [];
    return arr.concat(union).reduce((shape, next) => {
      const nextShape = _schemaShape(next, path);
      if (nextShape)
        shape = { ...shape ?? {}, ...nextShape };
      return shape;
    }, arr.length ? {} : void 0);
  }
  if (info.properties) {
    const output = {};
    for (const [key, prop] of Object.entries(info.properties)) {
      const shape = _schemaShape(prop, [...path, key]);
      if (shape)
        output[key] = shape;
    }
    return output;
  }
  return info.types.includes("array") || info.types.includes("object") ? {} : void 0;
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/defaults.js
function defaults(defaults2, adapter, options) {
  if (defaults2 && "superFormValidationLibrary" in defaults2) {
    options = adapter;
    adapter = defaults2;
    defaults2 = null;
  }
  const validator = adapter;
  const optionDefaults = (options == null ? void 0 : options.defaults) ?? validator.defaults;
  return {
    id: (options == null ? void 0 : options.id) ?? validator.id,
    valid: false,
    posted: false,
    errors: {},
    data: { ...optionDefaults, ...defaults2 },
    constraints: validator.constraints
  };
}
function defaultValues2(adapter) {
  return adapter.defaults;
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/actionResult.js
import { json } from "@sveltejs/kit";
function actionResult(type, data, options) {
  function cookieData() {
    var _a, _b, _c, _d;
    if (typeof options === "number" || !(options == null ? void 0 : options.message))
      return "";
    const extra = [
      `Path=${((_a = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _a.path) || "/"}`,
      `Max-Age=${((_b = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _b.maxAge) || 120}`,
      `SameSite=${((_c = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _c.sameSite) ?? "Strict"}`
    ];
    if ((_d = options == null ? void 0 : options.cookieOptions) == null ? void 0 : _d.secure) {
      extra.push(`Secure`);
    }
    return `flash=${encodeURIComponent(JSON.stringify(options.message))}; ` + extra.join("; ");
  }
  const status = options && typeof options !== "number" ? options.status : options;
  const result = (struct) => {
    return json({ type, ...struct }, {
      status: struct.status,
      headers: typeof options === "object" && options.message ? {
        "Set-Cookie": cookieData()
      } : void 0
    });
  };
  if (type == "error") {
    return result({
      status: status || 500,
      error: typeof data === "string" ? { message: data } : data
    });
  } else if (type == "redirect") {
    return result({
      status: status || 303,
      location: data
    });
  } else if (type == "failure") {
    return result({
      status: status || 400,
      data: stringify(data)
    });
  } else {
    return result({ status: status || 200, data: stringify(data) });
  }
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/superValidate.js
import { fail } from "@sveltejs/kit";

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/formData.js
var legacyMode2 = false;
try {
  if (SUPERFORMS_LEGACY)
    legacyMode2 = true;
} catch {
}
async function parseRequest(data, schemaData, options) {
  let parsed;
  if (data instanceof FormData) {
    parsed = parseFormData(data, schemaData, options);
  } else if (data instanceof URL || data instanceof URLSearchParams) {
    parsed = parseSearchParams(data, schemaData, options);
  } else if (data instanceof Request) {
    parsed = await tryParseFormData(data, schemaData, options);
  } else if (
    // RequestEvent
    data && typeof data === "object" && "request" in data && data.request instanceof Request
  ) {
    parsed = await tryParseFormData(data.request, schemaData, options);
  } else {
    parsed = {
      id: void 0,
      data,
      posted: false
    };
  }
  return parsed;
}
async function tryParseFormData(request, schemaData, options) {
  let formData = void 0;
  try {
    formData = await request.formData();
  } catch (e) {
    if (e instanceof TypeError && e.message.includes("already been consumed")) {
      throw e;
    }
    return { id: void 0, data: void 0, posted: false };
  }
  return parseFormData(formData, schemaData, options);
}
function parseSearchParams(data, schemaData, options) {
  if (data instanceof URL)
    data = data.searchParams;
  const convert = new FormData();
  for (const [key, value] of data.entries()) {
    convert.append(key, value);
  }
  const output = parseFormData(convert, schemaData, options);
  output.posted = false;
  return output;
}
function parseFormData(formData, schemaData, options) {
  var _a;
  function tryParseSuperJson() {
    if (formData.has("__superform_json")) {
      try {
        const output = parse(formData.getAll("__superform_json").join("") ?? "");
        if (typeof output === "object") {
          const filePaths = Array.from(formData.keys());
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_file_"))) {
            const realPath = splitPath(path.substring(17));
            setPaths(output, [realPath], formData.get(path));
          }
          for (const path of filePaths.filter((path2) => path2.startsWith("__superform_files_"))) {
            const realPath = splitPath(path.substring(18));
            const allFiles = formData.getAll(path);
            setPaths(output, [realPath], Array.from(allFiles));
          }
          return output;
        }
      } catch {
      }
    }
    return null;
  }
  const data = tryParseSuperJson();
  const id = (_a = formData.get("__superform_id")) == null ? void 0 : _a.toString();
  return data ? { id, data, posted: true } : {
    id,
    data: _parseFormData(formData, schemaData, options),
    posted: true
  };
}
function _parseFormData(formData, schema, options) {
  var _a;
  const output = {};
  const schemaKeys = new Set([
    ...Object.keys(schema.properties ?? {}),
    ...schema.additionalProperties ? formData.keys() : []
  ].filter((key) => !key.startsWith("__superform_")));
  function parseSingleEntry(key, entry, info) {
    if ((options == null ? void 0 : options.preprocessed) && options.preprocessed.includes(key)) {
      return entry;
    }
    if (entry && typeof entry !== "string") {
      const allowFiles = legacyMode2 ? (options == null ? void 0 : options.allowFiles) === true : (options == null ? void 0 : options.allowFiles) !== false;
      return allowFiles && (entry.size || entry.name) ? entry : void 0;
    }
    if (info.types.length > 1) {
      throw new SchemaError('FormData parsing failed: Multiple types are only supported when the dataType option for superForm is set to "json".Types found: ' + info.types, key);
    }
    const [type] = info.types;
    return parseFormDataEntry(key, entry, type ?? "any", info);
  }
  const defaultPropertyType = typeof schema.additionalProperties == "object" ? schema.additionalProperties : { type: "string" };
  for (const key of schemaKeys) {
    const property = schema.properties ? schema.properties[key] : defaultPropertyType;
    if (typeof property == "boolean") {
      throw new SchemaError("Schema properties defined as boolean is not supported.", key);
    }
    const info = schemaInfo(property ?? defaultPropertyType, !((_a = schema.required) == null ? void 0 : _a.includes(key)), [
      key
    ]);
    if (!info)
      continue;
    if (!info.types.includes("boolean") && !schema.additionalProperties && !formData.has(key)) {
      continue;
    }
    const entries = formData.getAll(key);
    if (info.union && info.union.length > 1) {
      throw new SchemaError('Unions (anyOf) are only supported when the dataType option for superForm is set to "json".', key);
    }
    if (info.types.includes("array") || info.types.includes("set")) {
      const items = property.items;
      if (!items || typeof items == "boolean" || Array.isArray(items) && items.length != 1) {
        throw new SchemaError('Arrays must have a single "items" property that defines its type.', key);
      }
      const arrayType = Array.isArray(items) ? items[0] : items;
      if (typeof arrayType == "boolean") {
        throw new SchemaError("Schema properties defined as boolean is not supported.", key);
      }
      const arrayInfo = schemaInfo(arrayType, info.isOptional, [key]);
      if (!arrayInfo)
        continue;
      const arrayData = entries.map((e) => parseSingleEntry(key, e, arrayInfo));
      output[key] = info.types.includes("set") ? new Set(arrayData) : arrayData;
    } else {
      output[key] = parseSingleEntry(key, entries[entries.length - 1], info);
    }
  }
  return output;
}
function parseFormDataEntry(key, value, type, info) {
  if (!value) {
    if (type == "boolean" && info.isOptional && info.schema.default === true) {
      return false;
    }
    const defaultValue2 = defaultValues(info.schema, info.isOptional, [key]);
    if (info.schema.enum && defaultValue2 !== null && defaultValue2 !== void 0) {
      return value;
    }
    if (defaultValue2 !== void 0)
      return defaultValue2;
    if (info.isNullable)
      return null;
    if (info.isOptional)
      return void 0;
  }
  function typeError() {
    throw new SchemaError(type[0].toUpperCase() + type.slice(1) + ` type found. Set the dataType option to "json" and add use:enhance on the client to use nested data structures. More information: https://superforms.rocks/concepts/nested-data`, key);
  }
  switch (type) {
    case "string":
    case "any":
      return value;
    case "integer":
      return parseInt(value ?? "", 10);
    case "number":
      return parseFloat(value ?? "");
    case "boolean":
      return Boolean(value == "false" ? "" : value).valueOf();
    case "unix-time": {
      const date = new Date(value ?? "");
      return !isNaN(date) ? date : void 0;
    }
    case "bigint":
      return BigInt(value ?? ".");
    case "symbol":
      return Symbol(String(value));
    case "set":
    case "array":
    case "object":
      return typeError();
    default:
      throw new SuperFormError("Unsupported schema type for FormData: " + type);
  }
}

// node_modules/.pnpm/sveltekit-superforms@2.5.0_@sveltejs+kit@2.5.1_@types+json-schema@7.0.15_esbuild-runner@2.2.2_wyrudk7jxakccuvpy44bsvpb4m/node_modules/sveltekit-superforms/dist/superValidate.js
async function superValidate(data, adapter, options) {
  if (data && "superFormValidationLibrary" in data) {
    options = adapter;
    adapter = data;
    data = void 0;
  }
  const validator = adapter;
  const defaults2 = (options == null ? void 0 : options.defaults) ?? validator.defaults;
  const jsonSchema = validator.jsonSchema;
  const parsed = await parseRequest(data, jsonSchema, options);
  const addErrors = (options == null ? void 0 : options.errors) ?? ((options == null ? void 0 : options.strict) ? true : !!parsed.data);
  const parsedData = (options == null ? void 0 : options.strict) ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults2);
  let status;
  if (!!parsed.data || addErrors) {
    status = await validator.validate(parsedData);
  } else {
    status = { success: false, issues: [] };
  }
  const valid = status.success;
  const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator.shape);
  const dataWithDefaults = valid ? status.data : replaceInvalidDefaults((options == null ? void 0 : options.strict) ? mergeDefaults(parsedData, defaults2) : parsedData, defaults2, jsonSchema, status.issues, options == null ? void 0 : options.preprocessed);
  let outputData;
  if (jsonSchema.additionalProperties === false) {
    outputData = {};
    for (const key of Object.keys(jsonSchema.properties ?? {})) {
      if (key in dataWithDefaults)
        outputData[key] = dataWithDefaults[key];
    }
  } else {
    outputData = dataWithDefaults;
  }
  const output = {
    id: parsed.id ?? (options == null ? void 0 : options.id) ?? validator.id,
    valid,
    posted: parsed.posted,
    errors,
    data: outputData
  };
  if (!parsed.posted) {
    output.constraints = validator.constraints;
    if (Object.keys(validator.shape).length) {
      output.shape = validator.shape;
    }
  }
  return output;
}
function message(form, message2, options) {
  if ((options == null ? void 0 : options.status) && options.status >= 400) {
    form.valid = false;
  }
  form.message = message2;
  const remove = (options == null ? void 0 : options.removeFiles) !== false;
  const output = remove ? withFiles({ form }) : { form };
  return form.valid ? output : fail((options == null ? void 0 : options.status) ?? 400, output);
}
var setMessage = message;
function setError(form, path, error, options) {
  if (error == void 0 || typeof error !== "string" && !Array.isArray(error)) {
    options = error;
    error = path;
    path = "";
  }
  if (options === void 0)
    options = {};
  const errArr = Array.isArray(error) ? error : [error];
  if (!form.errors)
    form.errors = {};
  if (path === null || path === "") {
    if (!form.errors._errors)
      form.errors._errors = [];
    form.errors._errors = options.overwrite ? errArr : form.errors._errors.concat(errArr);
  } else {
    const realPath = splitPath(path);
    const leaf = traversePath(form.errors, realPath, ({ parent, key, value }) => {
      if (value === void 0)
        parent[key] = {};
      return parent[key];
    });
    if (leaf) {
      leaf.parent[leaf.key] = Array.isArray(leaf.value) && !options.overwrite ? leaf.value.concat(errArr) : errArr;
    }
  }
  form.valid = false;
  const output = options.removeFiles === false ? { form } : withFiles({ form });
  return fail(options.status ?? 400, output);
}
function withFiles(obj) {
  if (typeof obj !== "object")
    return obj;
  for (const key in obj) {
    const value = obj[key];
    if (value instanceof File)
      delete obj[key];
    else if (value && typeof value === "object")
      withFiles(value);
  }
  return obj;
}
var removeFiles = withFiles;
export {
  actionResult,
  arrayProxy,
  booleanProxy,
  dateProxy,
  defaultValues2 as defaultValues,
  defaults,
  fieldProxy,
  formFieldProxy,
  intProxy,
  message,
  numberProxy,
  removeFiles,
  schemaShape,
  setError,
  setMessage,
  stringProxy,
  superForm,
  superValidate,
  withFiles
};
//# sourceMappingURL=sveltekit-superforms_client.js.map
